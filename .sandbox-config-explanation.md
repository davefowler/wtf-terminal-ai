# Sandbox Configuration Explanation

This file explains why the sandbox is configured the way it is.

## Philosophy: "Permissive for Work, Strict on Credentials"

The sandbox config is designed to be **maximally permissive for development** while **strictly blocking credential access**.

### Why This Approach?

1. **Commands aren't restricted** - Python, pytest, pip, git, npm, etc. all run normally
2. **File/network access is restricted** - What those commands can read/write/access is controlled
3. **Development shouldn't be painful** - If you need /tmp or system libraries, you should have them
4. **Credentials must be protected** - SSH keys and cloud credentials are the crown jewels

## What's Allowed

### Filesystem Write Access

```json
"Edit(.)",        // Your project - obviously needed
"Edit(/tmp)",     // Tests often need temp files
"Edit(/var/tmp)"  // Alternative temp location
```

**Why /tmp?**
- pytest creates temp files
- Many Python libraries use /tmp for caching
- Test fixtures often write to /tmp
- Coverage reports may use temp space

### Filesystem Read Access

```json
"Read(.)",            // Your project
"Read(/usr)",         // System Python, libraries, binaries
"Read(/Library)",     // macOS system libraries
"Read(/System/Library)" // macOS system frameworks
```

**Why system paths?**
- Python is in /usr/bin/python or /usr/local/bin/python
- Python libraries are in /usr/lib/python3.x or /Library/Python
- Development tools (git, make, etc.) are in /usr/bin
- Without these, nothing would work!

**Note:** By default, sandbox allows read access everywhere. We're just being explicit.

### Network Access

```json
"WebFetch(domain:pypi.org)",              // pip install
"WebFetch(domain:files.pythonhosted.org)", // Package downloads
"WebFetch(domain:anthropic.com)",         // Claude API
"WebFetch(domain:openai.com)",            // GPT API
"WebFetch(domain:googleapis.com)",        // Gemini API
"WebFetch(domain:github.com)",            // Git operations
"WebFetch(domain:api.github.com)",        // GitHub API
"WebFetch(domain:raw.githubusercontent.com)", // Raw file access
"WebFetch(domain:objects.githubusercontent.com)" // Git objects
```

**Why these domains?**
- **PyPI**: Required for `pip install` to work
- **AI APIs**: Required for testing AI integration
- **GitHub**: Required for git push/pull/clone
- **Nothing else**: Prevents data exfiltration to random domains

## What's Blocked

### Critical Credential Files

```json
// SSH Keys
"Read(~/.ssh/id_rsa)",
"Read(~/.ssh/id_ed25519)",
"Read(~/.ssh/id_ecdsa)",

// Cloud Credentials
"Read(~/.aws/credentials)",
"Read(~/.aws/config)",
"Read(~/.config/gcloud/credentials.db)",
"Read(~/.docker/config.json)",

// Network credentials
"Read(~/.netrc)"
```

**Why block these?**
- These files contain secrets that could compromise your entire infrastructure
- If Claude Code (or any AI agent) reads these, they could be sent to the AI API
- Even accidental exposure could be catastrophic
- You should NEVER need to read these files during development

### Shell Configuration Files

```json
"Edit(~/.bashrc)",
"Edit(~/.zshrc)",
"Edit(~/.bash_profile)"
```

**Why block these?**
- Prevents persistence attacks
- If an AI agent modifies these, malicious code runs every time you open a terminal
- Shell configs should be sacred - manual editing only
- Read access is fine, but write access is dangerous

### Configuration Directories

```json
"Edit(~/.ssh)",
"Edit(~/.aws)",
"Edit(~/.config/gcloud)"
```

**Why block these?**
- Prevents creating new credential files in these directories
- Prevents modifying SSH authorized_keys (backdoor risk)
- Prevents modifying AWS/GCP configs to point to attacker infrastructure

## Common Development Scenarios

### Scenario: Running Tests

**What happens:**
```bash
pytest tests/
```

**Sandbox allows:**
- ✅ Read test files from project directory
- ✅ Write temp files to /tmp
- ✅ Read Python libraries from /usr
- ✅ Write coverage reports to project directory
- ✅ Network calls to mocked APIs (local)

**Sandbox blocks:**
- ❌ Reading your SSH keys (tests don't need them)
- ❌ Writing to your home directory outside project
- ❌ Network calls to non-allowed domains

### Scenario: Installing Packages

**What happens:**
```bash
pip install rich pytest coverage
```

**Sandbox allows:**
- ✅ Network access to pypi.org and files.pythonhosted.org
- ✅ Write to virtual environment (in project directory)
- ✅ Write to /tmp for package extraction
- ✅ Read system Python to determine compatibility

**Sandbox blocks:**
- ❌ Installing packages globally to /usr (you're using venv anyway)
- ❌ Network access to malicious package mirrors
- ❌ Post-install scripts reading your credentials

### Scenario: Git Operations

**What happens:**
```bash
git add .
git commit -m "feat: add feature"
git push origin main
```

**Sandbox allows:**
- ✅ Read/write .git directory in project
- ✅ Network access to github.com
- ✅ Read ~/.gitconfig for user info
- ✅ Read SSH public keys (~/.ssh/id_rsa.pub)

**Sandbox blocks:**
- ❌ Reading SSH private keys (git uses ssh-agent instead)
- ❌ Pushing to non-GitHub domains
- ❌ Modifying global git config outside project

### Scenario: Creating Virtual Environment

**What happens:**
```bash
python -m venv .venv
source .venv/bin/activate
pip install -r requirements.txt
```

**Sandbox allows:**
- ✅ Create .venv directory in project
- ✅ Copy Python from system to .venv
- ✅ Install packages to .venv
- ✅ Activate virtual environment

**Sandbox blocks:**
- Nothing! This works completely normally.

## Adjusting for Your Needs

### If You Need Docker

```json
{
  "permissions": {
    "allow": [
      "UnixSocket(/var/run/docker.sock)"
    ]
  }
}
```

**Warning:** This is powerful! Docker socket access = root access. Only add if essential.

### If You Need Local Database

```json
{
  "permissions": {
    "allow": [
      "Edit(/usr/local/var/postgres)",  // PostgreSQL data
      "UnixSocket(/tmp/.s.PGSQL.5432)"  // PostgreSQL socket
    ]
  }
}
```

### If You Need System Python Packages

```json
{
  "permissions": {
    "allow": [
      "Edit(/usr/local/lib/python3.11/site-packages)"
    ]
  }
}
```

**Note:** Better to use virtual environments instead!

## Security Notes

### What This DOESN'T Prevent

❌ **Logic bugs in your code** - Sandbox doesn't check code correctness
❌ **Bugs in Python/pip** - System commands run with system permissions
❌ **Supply chain attacks** - Malicious packages from PyPI can still harm your project
❌ **AI hallucinations** - AI can still suggest wrong/dangerous commands

### What This DOES Prevent

✅ **Credential theft** - AI can't read or exfiltrate your secrets
✅ **System compromise** - Can't modify system files or shell configs
✅ **Data exfiltration** - Network restricted to approved domains only
✅ **Lateral movement** - Can't escape to other directories
✅ **Persistence** - Can't modify shell configs to run on every terminal

## Testing Your Config

Before trusting the sandbox, test it:

```bash
# Should work (project file)
srt "cat SPEC.md" | head -n 5

# Should work (temp file)
srt "echo test > /tmp/test.txt && cat /tmp/test.txt"

# Should work (system read)
srt "python --version"

# Should work (pip install)
srt "pip install --dry-run rich"

# Should FAIL (SSH key)
srt "cat ~/.ssh/id_rsa"
# Expected: cat: /Users/you/.ssh/id_rsa: Operation not permitted

# Should FAIL (AWS credentials)
srt "cat ~/.aws/credentials"
# Expected: cat: /Users/you/.aws/credentials: Operation not permitted

# Should FAIL (write outside project)
srt "touch ~/test.txt"
# Expected: touch: /Users/you/test.txt: Operation not permitted

# Should FAIL (blocked domain)
srt "curl https://evil.com"
# Expected: Connection blocked by network allowlist
```

If all tests pass as expected, your sandbox is configured correctly!

## Further Reading

- [Sandbox Runtime Docs](https://github.com/anthropic-experimental/sandbox-runtime)
- [Seatbelt (macOS) Profiles](https://reverse.put.as/wp-content/uploads/2011/09/Apple-Sandbox-Guide-v1.0.pdf)
- [Bubblewrap (Linux) Documentation](https://github.com/containers/bubblewrap)

---

**TL;DR:** Sandbox lets all development tools work normally (Python, pip, pytest, git) while strictly blocking access to credentials (SSH keys, AWS/GCP tokens, Docker config). It's designed to be invisible during normal work and only trigger on actual security violations.

